/**\n * Auth Service\n * Contains all authentication and authorization business logic\n */\n\nimport bcrypt from 'bcryptjs';\nimport { randomUUID } from 'crypto';\nimport userRepository from '../repositories/user.repository.js';\nimport { generateOTPWithExpiry, hashOTP, verifyOTP } from './otp.service.js';\nimport { sendOtpEmail, sendWelcomeEmail } from './email.service.js';\nimport { generateToken } from '../middleware/auth.js';\n\nexport class AuthService {\n  /**\n   * Register new user\n   * @param {Object} userData - User registration data\n   * @returns {Promise<Object>}\n   */\n  async register(userData) {\n    const { email, password, firstName, lastName } = userData;\n    \n    // Check if user already exists\n    const existingUser = await userRepository.findByEmail(email);\n    if (existingUser) {\n      throw new Error('User already exists with this email');\n    }\n    \n    // Validate password strength\n    if (password.length < 8) {\n      throw new Error('Password must be at least 8 characters long');\n    }\n    \n    // Hash password\n    const hashedPassword = await bcrypt.hash(password, 10);\n    \n    // Create user\n    const userId = randomUUID();\n    const displayName = [firstName, lastName].filter(Boolean).join(' ').trim() || email;\n    \n    const newUser = await userRepository.create({\n      id: userId,\n      email: email.toLowerCase().trim(),\n      password: hashedPassword,\n      firstName,\n      lastName,\n      displayName,\n      authProvider: 'password',\n      emailVerified: false,\n      isActive: true,\n      isAdmin: false,\n    });\n    \n    // Send welcome email (non-blocking)\n    sendWelcomeEmail(newUser.email, newUser.displayName).catch(err => {\n      console.error('Welcome email failed:', err);\n    });\n    \n    // Generate JWT token\n    const token = generateToken({\n      id: newUser.id,\n      email: newUser.email,\n      isAdmin: newUser.isAdmin,\n    });\n    \n    // Remove password from response\n    const { password: _, ...userWithoutPassword } = newUser;\n    \n    return {\n      user: userWithoutPassword,\n      token,\n    };\n  }\n\n  /**\n   * Login user\n   * @param {string} email - User email\n   * @param {string} password - User password\n   * @returns {Promise<Object>}\n   */\n  async login(email, password) {\n    // Find user\n    const user = await userRepository.findByEmail(email);\n    \n    if (!user || !user.password) {\n      throw new Error('Invalid credentials');\n    }\n    \n    // Check if user is active\n    if (!user.isActive) {\n      throw new Error('Account is inactive. Please contact support.');\n    }\n    \n    // Verify password\n    const isPasswordValid = await bcrypt.compare(password, user.password);\n    \n    if (!isPasswordValid) {\n      throw new Error('Invalid credentials');\n    }\n    \n    // Update last login\n    await userRepository.updateLastLogin(user.id);\n    \n    // Generate JWT token\n    const token = generateToken({\n      id: user.id,\n      email: user.email,\n      isAdmin: user.isAdmin,\n    });\n    \n    // Remove password from response\n    const { password: _, ...userWithoutPassword } = user;\n    \n    return {\n      user: userWithoutPassword,\n      token,\n    };\n  }\n\n  /**\n   * Google OAuth login/register\n   * @param {string} googleId - Google ID\n   * @param {Object} profileData - Google profile data\n   * @returns {Promise<Object>}\n   */\n  async googleAuth(googleId, profileData) {\n    const { email, name, picture } = profileData;\n    \n    // Find user by Google ID or email\n    let user = await userRepository.findByGoogleId(googleId);\n    \n    if (!user) {\n      user = await userRepository.findByEmail(email);\n    }\n    \n    if (!user) {\n      // Create new user\n      const userId = randomUUID();\n      user = await userRepository.create({\n        id: userId,\n        email: email.toLowerCase().trim(),\n        googleId,\n        displayName: name,\n        photoURL: picture,\n        authProvider: 'google',\n        emailVerified: true,\n        isActive: true,\n        isAdmin: false,\n      });\n      \n      // Send welcome email\n      sendWelcomeEmail(user.email, user.displayName).catch(err => {\n        console.error('Welcome email failed:', err);\n      });\n    } else if (!user.googleId) {\n      // Link Google account\n      user = await userRepository.update(user.id, {\n        googleId,\n        photoURL: picture || user.photoURL,\n        emailVerified: true,\n      });\n    }\n    \n    // Update last login\n    await userRepository.updateLastLogin(user.id);\n    \n    // Generate JWT token\n    const token = generateToken({\n      id: user.id,\n      email: user.email,\n      isAdmin: user.isAdmin,\n    });\n    \n    return {\n      user,\n      token,\n    };\n  }\n\n  /**\n   * Request password reset\n   * @param {string} email - User email\n   * @returns {Promise<Object>}\n   */\n  async requestPasswordReset(email) {\n    const user = await userRepository.findByEmail(email);\n    \n    // Always return success to prevent email enumeration\n    const response = {\n      success: true,\n      message: 'If an account exists with this email, an OTP has been sent.',\n    };\n    \n    if (!user || !user.isActive) {\n      return response;\n    }\n    \n    // Generate OTP\n    const { otp, expiresAt } = generateOTPWithExpiry(10);\n    const hashedOtp = hashOTP(otp);\n    \n    // Save OTP to database\n    await userRepository.setPasswordResetToken(user.id, hashedOtp, expiresAt);\n    \n    // Send OTP email\n    const emailResult = await sendOtpEmail(user.email, otp, 10);\n    \n    // In development, include OTP in response\n    if (process.env.NODE_ENV === 'development') {\n      response.otp = otp;\n      response.expiresAt = expiresAt;\n    }\n    \n    return response;\n  }\n\n  /**\n   * Verify OTP\n   * @param {string} email - User email\n   * @param {string} otp - OTP code\n   * @returns {Promise<Object>}\n   */\n  async verifyOTP(email, otp) {\n    const user = await userRepository.findByEmail(email);\n    \n    if (!user) {\n      throw new Error('Invalid OTP');\n    }\n    \n    // Verify OTP\n    const verification = verifyOTP(otp, user.passwordResetToken, user.passwordResetExpires);\n    \n    if (!verification.valid) {\n      throw new Error(verification.error);\n    }\n    \n    // Generate reset token for final password reset\n    const resetToken = randomUUID();\n    const hashedResetToken = hashOTP(resetToken);\n    const newExpiry = new Date(Date.now() + 10 * 60 * 1000);\n    \n    await userRepository.setPasswordResetToken(user.id, hashedResetToken, newExpiry);\n    \n    return {\n      success: true,\n      message: 'OTP verified successfully',\n      resetToken,\n    };\n  }\n\n  /**\n   * Reset password\n   * @param {string} email - User email\n   * @param {string} resetToken - Reset token\n   * @param {string} newPassword - New password\n   * @returns {Promise<Object>}\n   */\n  async resetPassword(email, resetToken, newPassword) {\n    const user = await userRepository.findByEmail(email);\n    \n    if (!user) {\n      throw new Error('Invalid reset token');\n    }\n    \n    // Verify reset token\n    const hashedToken = hashOTP(resetToken);\n    const verification = verifyOTP(resetToken, user.passwordResetToken, user.passwordResetExpires);\n    \n    if (!verification.valid) {\n      throw new Error('Invalid or expired reset token');\n    }\n    \n    // Validate new password\n    if (newPassword.length < 8) {\n      throw new Error('Password must be at least 8 characters long');\n    }\n    \n    // Hash new password\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\n    \n    // Update password\n    await userRepository.update(user.id, {\n      password: hashedPassword,\n    });\n    \n    // Clear reset token\n    await userRepository.clearPasswordResetToken(user.id);\n    \n    return {\n      success: true,\n      message: 'Password reset successfully',\n    };\n  }\n\n  /**\n   * Get user profile\n   * @param {string} userId - User ID\n   * @returns {Promise<Object>}\n   */\n  async getProfile(userId) {\n    const user = await userRepository.findById(userId);\n    \n    if (!user) {\n      throw new Error('User not found');\n    }\n    \n    // Remove sensitive fields\n    const { password, passwordResetToken, passwordResetExpires, ...profile } = user;\n    \n    return profile;\n  }\n\n  /**\n   * Update user profile\n   * @param {string} userId - User ID\n   * @param {Object} profileData - Profile data to update\n   * @returns {Promise<Object>}\n   */\n  async updateProfile(userId, profileData) {\n    const user = await userRepository.findById(userId);\n    \n    if (!user) {\n      throw new Error('User not found');\n    }\n    \n    // Update profile\n    const updatedUser = await userRepository.updateProfile(userId, profileData);\n    \n    // Remove sensitive fields\n    const { password, passwordResetToken, passwordResetExpires, ...profile } = updatedUser;\n    \n    return profile;\n  }\n\n  /**\n   * Change password\n   * @param {string} userId - User ID\n   * @param {string} currentPassword - Current password\n   * @param {string} newPassword - New password\n   * @returns {Promise<Object>}\n   */\n  async changePassword(userId, currentPassword, newPassword) {\n    const user = await userRepository.findById(userId);\n    \n    if (!user || !user.password) {\n      throw new Error('Cannot change password for this account');\n    }\n    \n    // Verify current password\n    const isPasswordValid = await bcrypt.compare(currentPassword, user.password);\n    \n    if (!isPasswordValid) {\n      throw new Error('Current password is incorrect');\n    }\n    \n    // Validate new password\n    if (newPassword.length < 8) {\n      throw new Error('Password must be at least 8 characters long');\n    }\n    \n    // Hash new password\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\n    \n    // Update password\n    await userRepository.update(userId, {\n      password: hashedPassword,\n    });\n    \n    return {\n      success: true,\n      message: 'Password changed successfully',\n    };\n  }\n}\n\nexport default new AuthService();\n